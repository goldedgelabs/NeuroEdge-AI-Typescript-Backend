import { DoctrineEngine } from "../engines/DoctrineEngine";

export const engineManager: Record<string, any> = {};
const doctrine = new DoctrineEngine();

// Register engines with Doctrine enforcement
export function registerEngine(name: string, engineInstance: any) {
  engineManager[name] = new Proxy(engineInstance, {
    get(target, prop: string) {
      const origMethod = target[prop];
      if (typeof origMethod === "function") {
        return async (...args: any[]) => {
          const action = `${name}.${prop}`;
          const folderArg = args[0]?.folder || "";
          const userRole = args[0]?.role || "user";

          const doctrineResult = await doctrine.enforceAction(action, folderArg, userRole);
          if (!doctrineResult.success) {
            console.warn(`[Doctrine] Action blocked: ${action}`);
            return { blocked: true, message: doctrineResult.message };
          }
          return origMethod.apply(target, args);
        };
      }
      return origMethod;
    }
  });
}

// Utility: run multiple engines in sequence (chain)
export async function runEngineChain(chain: string[], payload: any) {
  let data = payload;
  for (const engineName of chain) {
    const engine = engineManager[engineName];
    if (!engine) throw new Error(`Engine not found: ${engineName}`);
    data = await engine.run(data);
  }
  return data;
}

// Optional: trigger engine-to-engine events via simple bus
export const eventBus: Record<string, Function[]> = {};
export function subscribe(channel: string, callback: Function) {
  if (!eventBus[channel]) eventBus[channel] = [];
  eventBus[channel].push(callback);
}
export function publish(channel: string, data: any) {
  const subscribers = eventBus[channel] || [];
  subscribers.forEach(cb => cb(data));
    }
